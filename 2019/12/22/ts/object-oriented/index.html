<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>TypeScript——面向对象 | 夏木なつき青あお</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
      <link rel="icon" href="/favicon.png">
    

    
<link rel="stylesheet" href="/css/style.css">


    
<link rel="stylesheet" href="/js/google-code-prettify/codestyle.css">


  <meta name="generator" content="Hexo 6.0.0"></head>

  <body>

<header>
	<a id="logo" target="_blank" rel="noopener" href="https://xiamuqing.github.io/" title="夏木なつき青あお">
	<img src="/favicon.png" alt="夏木なつき青あお"></a>
	
	
		<!--搜索栏-->
		<i class="js-toggle-search iconfont icon-search"></i>


<form class="js-search search-form search-form--modal" method="get" action="http://gushi.li" role="search">
	<div class="search-form__inner">
		<div>
			<i class="iconfont icon-search"></i>
			<input class="text-input" placeholder="Enter Key..." type="search">
		</div>
	</div>
</form>
	

	
		<!--侧边导航栏-->
		<a id="nav-toggle" href="#"><span></span></a>

<nav>
	<div class="menu-top-container">
		<ul id="menu-top" class="menu">
			
				
				<li class="current-menu-item">
					<a href="https://b23.tv/0haAVni" target="_blank">今日走过所有的弯路，从此尽是平坦路</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/aeEKARwDs-a0W9xHz_4ljw" target="_blank">天府之国</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/UmcR2tPKSrxN5WeDpBl2fA" target="_blank">雾漫小东江</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/Kjcx0dGnY6ok9AhbFI-4Lg" target="_blank">古色苏州</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/Boyogn1SY0qmwTop7uIyxg" target="_blank">多彩贵州</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/-s1T-4YrgM0AgzcPVuTdag" target="_blank">雨后彩虹</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/xAmrZ3qEk2uOzLKjFJgvLw" target="_blank">20元畅游阳朔</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/73eeFCUkYhJhe2kkwdvhzg" target="_blank">网红打卡郴州</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/EKPU36p2NaA71TjmdguhdA" target="_blank">西安古城</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/23isnvdaozHOptQQDupjzQ" target="_blank">山西大同</a>
				</li>
			
		</ul>
	</div>
</nav>
	

</header>
<div class="m-header ">
	<section id="hero1" class="hero">
		<div class="inner">
		</div>
	</section>
	
		<figure class="top-image" data-enable=true></figure>
	
</div>

<!--文章列表-->
<div class="wrapper">
  
    <!--文章-->
<article>
	
  
    <h1 class="post-title" itemprop="name">
      TypeScript——面向对象
    </h1>
  

	<div class='post-body mb'>
		<!-- toc -->

<p>面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。</p>
<ul>
<li>举例来说：<ul>
<li>操作浏览器要使用window对象</li>
<li>操作网页要使用document对象</li>
<li>操作控制台要使用console对象</li>
</ul>
</li>
</ul>
<p>一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。</p>
<p>在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。</p>
<h2 id="1、类（class）"><a href="#1、类（class）" class="headerlink" title="1、类（class）"></a>1、类（class）</h2><p>要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。</p>
<ul>
<li><p>定义类：</p>
<ul>
<li><pre><code class="typescript">class 类名 &#123;
    属性名: 类型;
    
    constructor(参数: 类型)&#123;
        this.属性名 = 参数;
    &#125;
    
    方法名()&#123;
        ....
    &#125;

&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="typescript">class Person&#123;
    name: string;
    age: number;

    constructor(name: string, age: number)&#123;
        this.name = name;
        this.age = age;
    &#125;

    sayHello()&#123;
        console.log(`大家好，我是$&#123;this.name&#125;`);
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>使用类：</p>
<ul>
<li><pre><code class="typescript">const p = new Person(&#39;孙悟空&#39;, 18);
p.sayHello();
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="2、面向对象的特点"><a href="#2、面向对象的特点" class="headerlink" title="2、面向对象的特点"></a>2、面向对象的特点</h2><ul>
<li><p>封装</p>
<ul>
<li><p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p>
</li>
<li><p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</p>
</li>
<li><p>只读属性（readonly）：</p>
<ul>
<li>如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改</li>
</ul>
</li>
<li><p>TS中属性具有三种修饰符：</p>
<ul>
<li>public（默认值），可以在类、子类和对象中修改</li>
<li>protected ，可以在类、子类中修改</li>
<li>private ，可以在类中修改</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><p>public</p>
<ul>
<li><pre><code class="typescript">class Person&#123;
    public name: string; // 写或什么都不写都是public
    public age: number;

    constructor(name: string, age: number)&#123;
        this.name = name; // 可以在类中修改
        this.age = age;
    &#125;

    sayHello()&#123;
        console.log(`大家好，我是$&#123;this.name&#125;`);
    &#125;
&#125;

class Employee extends Person&#123;
    constructor(name: string, age: number)&#123;
        super(name, age);
        this.name = name; //子类中可以修改
    &#125;
&#125;

const p = new Person(&#39;孙悟空&#39;, 18);
p.name = &#39;猪八戒&#39;;// 可以通过对象修改
</code></pre>
</li>
</ul>
</li>
<li><p>protected</p>
<ul>
<li><pre><code class="typescript">class Person&#123;
    protected name: string;
    protected age: number;

    constructor(name: string, age: number)&#123;
        this.name = name; // 可以修改
        this.age = age;
    &#125;

    sayHello()&#123;
        console.log(`大家好，我是$&#123;this.name&#125;`);
    &#125;
&#125;

class Employee extends Person&#123;

    constructor(name: string, age: number)&#123;
        super(name, age);
        this.name = name; //子类中可以修改
    &#125;
&#125;

const p = new Person(&#39;孙悟空&#39;, 18);
p.name = &#39;猪八戒&#39;;// 不能修改
</code></pre>
</li>
</ul>
</li>
<li><p>private</p>
<ul>
<li><pre><code class="typescript">class Person&#123;
    private name: string;
    private age: number;

    constructor(name: string, age: number)&#123;
        this.name = name; // 可以修改
        this.age = age;
    &#125;

    sayHello()&#123;
        console.log(`大家好，我是$&#123;this.name&#125;`);
    &#125;
&#125;

class Employee extends Person&#123;

    constructor(name: string, age: number)&#123;
        super(name, age);
        this.name = name; //子类中不能修改
    &#125;
&#125;

const p = new Person(&#39;孙悟空&#39;, 18);
p.name = &#39;猪八戒&#39;;// 不能修改
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>属性存取器</p>
<ul>
<li><p>对于一些不希望被任意修改的属性，可以将其设置为private</p>
</li>
<li><p>直接将其设置为private将导致无法再通过对象修改其中的属性</p>
</li>
<li><p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p>
</li>
<li><p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="typescript">class Person&#123;
    private _name: string;

    constructor(name: string)&#123;
        this._name = name;
    &#125;

    get name()&#123;
        return this._name;
    &#125;

    set name(name: string)&#123;
        this._name = name;
    &#125;

&#125;

const p1 = new Person(&#39;孙悟空&#39;);
console.log(p1.name); // 通过getter读取name属性
p1.name = &#39;猪八戒&#39;; // 通过setter修改name属性
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>静态属性</p>
<ul>
<li><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p>
</li>
<li><p>静态属性（方法）使用static开头</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="typescript">class Tools&#123;
    static PI = 3.1415926;
    
    static sum(num1: number, num2: number)&#123;
        return num1 + num2
    &#125;
&#125;

console.log(Tools.PI);
console.log(Tools.sum(123, 456));
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>this</p>
<ul>
<li>在类中，使用this表示当前对象</li>
</ul>
</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li><p>继承时面向对象中的又一个特性</p>
</li>
<li><p>通过继承可以将其他类中的属性和方法引入到当前类中</p>
<ul>
<li><p>示例：</p>
<ul>
<li><pre><code class="typescript">class Animal&#123;
    name: string;
    age: number;

    constructor(name: string, age: number)&#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;

class Dog extends Animal&#123;

    bark()&#123;
        console.log(`$&#123;this.name&#125;在汪汪叫！`);
    &#125;
&#125;

const dog = new Dog(&#39;旺财&#39;, 4);
dog.bark();
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通过继承可以在不修改类的情况下完成对类的扩展</p>
</li>
<li><p>重写</p>
<ul>
<li><p>发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="typescript">class Animal&#123;
    name: string;
    age: number;

    constructor(name: string, age: number)&#123;
        this.name = name;
        this.age = age;
    &#125;

    run()&#123;
        console.log(`父类中的run方法！`);
    &#125;
&#125;

class Dog extends Animal&#123;

    bark()&#123;
        console.log(`$&#123;this.name&#125;在汪汪叫！`);
    &#125;

    run()&#123;
        console.log(`子类中的run方法，会重写父类中的run方法！`);
    &#125;
&#125;

const dog = new Dog(&#39;旺财&#39;, 4);
dog.bark();
</code></pre>
</li>
<li><p>在子类中可以使用super来完成对父类的引用</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象类（abstract class）</p>
<ul>
<li><p>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</p>
</li>
<li><pre><code class="typescript">abstract class Animal&#123;
    abstract run(): void;
    bark()&#123;
        console.log(&#39;动物在叫~&#39;);
    &#125;
&#125;

class Dog extends Animals&#123;
    run()&#123;
        console.log(&#39;狗在跑~&#39;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3、接口（Interface）"><a href="#3、接口（Interface）" class="headerlink" title="3、接口（Interface）"></a>3、接口（Interface）</h2><p>接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。</p>
<ul>
<li><p>示例（检查对象类型）：</p>
<ul>
<li><pre><code class="typescript">interface Person&#123;
    name: string;
    sayHello():void;
&#125;

function fn(per: Person)&#123;
    per.sayHello();
&#125;

fn(&#123;name:&#39;孙悟空&#39;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);
</code></pre>
</li>
</ul>
</li>
<li><p>示例（实现）</p>
<ul>
<li><pre><code class="typescript">interface Person&#123;
    name: string;
    sayHello():void;
&#125;

class Student implements Person&#123;
    constructor(public name: string) &#123;
    &#125;

    sayHello() &#123;
        console.log(&#39;大家好，我是&#39;+this.name);
    &#125;
&#125;
</code></pre>
</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="4、泛型（Generic）"><a href="#4、泛型（Generic）" class="headerlink" title="4、泛型（Generic）"></a>4、泛型（Generic）</h2><p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。</p>
<ul>
<li><p>举个例子：</p>
<ul>
<li><pre><code class="typescript">function test(arg: any): any&#123;
    return arg;
&#125;
</code></pre>
</li>
<li><p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</p>
</li>
<li><p>使用泛型：</p>
</li>
<li><pre><code class="typescript">function test&lt;T&gt;(arg: T): T&#123;
    return arg;
&#125;
</code></pre>
</li>
<li><p>这里的<code>&lt;T&gt;</code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。</p>
</li>
<li><p>那么如何使用上边的函数呢？</p>
<ul>
<li><p>方式一（直接使用）：</p>
<ul>
<li><pre><code class="typescript">test(10)
</code></pre>
</li>
<li><p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p>
</li>
</ul>
</li>
<li><p>方式二（指定类型）：</p>
<ul>
<li><pre><code class="typescript">test&lt;number&gt;(10)
</code></pre>
</li>
<li><p>也可以在函数后手动指定泛型</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可以同时指定多个泛型，泛型间使用逗号隔开：</p>
<ul>
<li><pre><code class="typescript">function test&lt;T, K&gt;(a: T, b: K): K&#123;
    return b;
&#125;

test&lt;number, string&gt;(10, &quot;hello&quot;);
</code></pre>
</li>
<li><p>使用泛型时，完全可以将泛型当成是一个普通的类去使用</p>
</li>
</ul>
</li>
<li><p>类中同样可以使用泛型：</p>
<ul>
<li><pre><code class="typescript">class MyClass&lt;T&gt;&#123;
    prop: T;

    constructor(prop: T)&#123;
        this.prop = prop;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>除此之外，也可以对泛型的范围进行约束</p>
<ul>
<li><pre><code class="typescript">interface MyInter&#123;
    length: number;
&#125;

function test&lt;T extends MyInter&gt;(arg: T): number&#123;
    return arg.length;
&#125;
</code></pre>
</li>
<li><p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="版权所属尚硅谷"><a href="#版权所属尚硅谷" class="headerlink" title="版权所属尚硅谷"></a>版权所属尚硅谷</h3>
	</div>
	<div class="meta split">
		<time class="post-date" datetime="2019-12-22T07:24:06.000Z" itemprop="datePublished">2019-12-22</time>
	</div>
</article>

<!--评论-->

	
<div class="ds-thread" data-thread-key="ts/object-oriented" data-title="TypeScript——面向对象" data-url="http://yoursite.com/2019/12/22/ts/object-oriented/"></div>
<script type="text/javascript">

var duoshuoQuery = {short_name:"yumemor"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>


  
</div>


  <svg id="bigTriangleColor" width="100%" height="40" viewBox="0 0 100 102" preserveAspectRatio="none">
    <path d="M0 0 L50 100 L100 0 Z"></path>
  </svg>

  


  <div class="wrapper"></div>





<div class="fat-footer">
	<div class="wrapper">
		<div class="layout layout--center">
			<div class="layout__item palm-mb">
				<div class="media">
					<img class="headimg" src='/avator.jpg' alt='Gator Law'>
					<div class="media__body">
						<h4>夏木なつき青あお</h4>
						<p class='site-description'>生命不息，折腾不止。</p>
					</div>
				</div>
				<div class="author-contact">
					<ul>
						
							
							<li>
				        		<a href="https://github.com/xiamuqing" target="_blank">
				        			
				        				<i class="iconfont icon-github"></i>
				        			
				        		</a>
				        	</li>
						
							
							<li>
				        		<a href="https://mp.weixin.qq.com/s/aeEKARwDs-a0W9xHz_4ljw" target="_blank">
				        			
				        				<i class="iconfont icon-douban"></i>
				        			
				        		</a>
				        	</li>
						
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>

<footer class="footer" role="contentinfo">
	<div class="wrapper wrapper--wide split split--responsive">
		<span>Theme by <a target="_blank" rel="noopener" href="http://github.com/yumemor">Yumemor</a>. Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></span>
	</div>
</footer>

	<!-－这里导入了 lib.js 里面涵盖了 jQuery 等框架 所以注释掉-->
	<!--
<script src="http://lib.sinaapp.com/js/jquery/2.0/jquery.min.js"></script>
-->
	
<script src="/js/lib.js"></script>

	
<script src="/js/google-code-prettify/prettify.js"></script>

	
<script src="/js/module.js"></script>

	
<script src="/js/script.js"></script>

	<script type='text/javascript'>
		//代码高亮
		$(document).ready(function(){
	 		$('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
   			prettyPrint();
		});
	</script>
	</body>
</html>