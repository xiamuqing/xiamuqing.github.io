<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>webRTC开发 | 夏木なつき青あお</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
      <link rel="icon" href="/favicon.png">
    

    
<link rel="stylesheet" href="/css/style.css">


    
<link rel="stylesheet" href="/js/google-code-prettify/codestyle.css">


  <meta name="generator" content="Hexo 6.0.0"></head>

  <body>

<header>
	<a id="logo" target="_blank" rel="noopener" href="https://xiamuqing.github.io/" title="夏木なつき青あお">
	<img src="/favicon.png" alt="夏木なつき青あお"></a>
	
	
		<!--搜索栏-->
		<i class="js-toggle-search iconfont icon-search"></i>


<form class="js-search search-form search-form--modal" method="get" action="http://gushi.li" role="search">
	<div class="search-form__inner">
		<div>
			<i class="iconfont icon-search"></i>
			<input class="text-input" placeholder="Enter Key..." type="search">
		</div>
	</div>
</form>
	

	
		<!--侧边导航栏-->
		<a id="nav-toggle" href="#"><span></span></a>

<nav>
	<div class="menu-top-container">
		<ul id="menu-top" class="menu">
			
				
				<li class="current-menu-item">
					<a href="https://b23.tv/0haAVni" target="_blank">今日走过所有的弯路，从此尽是平坦路</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/aeEKARwDs-a0W9xHz_4ljw" target="_blank">天府之国</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/UmcR2tPKSrxN5WeDpBl2fA" target="_blank">雾漫小东江</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/Kjcx0dGnY6ok9AhbFI-4Lg" target="_blank">古色苏州</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/Boyogn1SY0qmwTop7uIyxg" target="_blank">多彩贵州</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/-s1T-4YrgM0AgzcPVuTdag" target="_blank">雨后彩虹</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/xAmrZ3qEk2uOzLKjFJgvLw" target="_blank">20元畅游阳朔</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/73eeFCUkYhJhe2kkwdvhzg" target="_blank">网红打卡郴州</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/EKPU36p2NaA71TjmdguhdA" target="_blank">西安古城</a>
				</li>
			
				
				<li class="current-menu-item">
					<a href="https://mp.weixin.qq.com/s/23isnvdaozHOptQQDupjzQ" target="_blank">山西大同</a>
				</li>
			
		</ul>
	</div>
</nav>
	

</header>
<div class="m-header ">
	<section id="hero1" class="hero">
		<div class="inner">
		</div>
	</section>
	
		<figure class="top-image" data-enable=true></figure>
	
</div>

<!--文章列表-->
<div class="wrapper">
  
    <!--文章-->
<article>
	
  
    <h1 class="post-title" itemprop="name">
      webRTC开发
    </h1>
  

	<div class='post-body mb'>
		<h3 id="开发步骤："><a href="#开发步骤：" class="headerlink" title="开发步骤："></a>开发步骤：</h3><ol>
<li>获取本地媒体（getUserMedia()，MediaStream API）</li>
<li>在浏览器和对等端（其它浏览器或终端）之间建立对等连接（RTCPeerConnection API）<ul>
<li>RTCPeerConnection 接口代表一个由本地计算机到远端的 WebRTC 连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。</li>
<li>RTCSessionDescription 接口描述连接或潜在连接的一端的配置方式。每一个RTCSessionDescription 由一个描述类型组成，该描述类型指示它所描述的请求&#x2F;应答协商过程的SDP 协议的相关描述。RTCSessionDescription 在两个对等点之间协商连接的过程涉及来回交换对象，每个描述都表示描述的发送者支持的连接配置选项的一个组合。一旦两个对等方就连接的配置达成一致，协商就完成了。</li>
</ul>
</li>
<li>将媒体和数据通道关联至该连接</li>
<li>交换会话描述（RTCSessionDescription）<br><img src="/2023/07/17/js/webRTC/01/01.jpg"><ul>
<li>浏览器M从Web服务器请求网页</li>
<li>Web服务器向M返回带有WebRTC js的网页</li>
<li>浏览器L从Web服务器请求网页</li>
<li>Web服务器向L返回带有WebRTC js的网页</li>
<li>M决定与L通信，通过M自身的js将M的会话描述对象（offer，提议）发送至Web服务器</li>
<li>Web服务器将M的会话描述对象发送至L上的js</li>
<li>L上的js将L的会话描述对象（answer，应答）发送至Web服务器</li>
<li>Web服务器转发应答至M上的js</li>
<li>M和L开始交互，确定访问对方的最佳方式</li>
<li>完成后，M和L开始协商通信密钥</li>
<li>M和L开始交换语音、视频或数据</li>
</ul>
</li>
</ol>
<h3 id="获取本地媒体（getUserMedia"><a href="#获取本地媒体（getUserMedia" class="headerlink" title="获取本地媒体（getUserMedia"></a>获取本地媒体（getUserMedia</h3><pre><code class="html">&lt;p&gt;通过getUserMedia()获取视频&lt;/p&gt;
&lt;video id=&quot;video&quot; autoplay palysinline&gt;&lt;/video&gt;
&lt;button id=&quot;videoButton&quot; onclick=&quot;userOpt(&#39;video&#39;)&quot;&gt;打开摄像头&lt;/button&gt;

&lt;p&gt;通过getUserMedia()获取音频&lt;/p&gt;
&lt;audio id=&quot;audio&quot; autoplay controls&gt;&lt;/audio&gt;

&lt;button id=&quot;audioButton&quot; onclick=&quot;userOpt(&#39;audio&#39;)&quot;&gt;打开麦克风&lt;/button&gt;

&lt;p&gt;通过getUserMedia()获取音视频&lt;/p&gt;
&lt;!-- muted 静音 --&gt;
&lt;video id=&quot;allVideo&quot; autoplay palysinline muted&gt;&lt;/video&gt;
&lt;button id=&quot;allButton&quot; onclick=&quot;userOpt(&#39;all&#39;)&quot;&gt;全部打开&lt;/button&gt;
</code></pre>
<pre><code class="js">function userOpt(type) &#123;
    const constraints = &#123;
        audio: false,
        video: false
    &#125;
    switch (type) &#123;
        case &#39;audio&#39;:
            constraints.audio = true
        break
        case &#39;video&#39;:
            constraints.video = true
        case &#39;all&#39;:
            constraints.video = true
            constraints.audio = true
    &#125;
    // 注意getUserMedia()在各浏览器中的区别
    // Opera --&gt; getUserMedia
    // Chrome --&gt; webkitGetUserMedia
    // Firefox --&gt; mozGetUserMedia
    //navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
    navigator.mediaDevices.getUserMedia(constraints).then((stream) =&gt; &#123;
        handleSuccess(stream, type)
    &#125;).catch(handleError)
&#125;


function handleSuccess(stream, type) &#123;
    type = type === &#39;all&#39; ? &#39;allVideo&#39; : type
    const ele = document.querySelector(`#$&#123;type&#125;`)
    try &#123;
        // Chrome浏览器
        ele.srcObject = stream
    &#125; catch &#123;
        // 这里是兼容写法
        let compatibleURL = window.URL || window.webkitURL;
        ele.src = compatibleURL.createObjectURL(stream);
    &#125;
&#125;

function handleError(error) &#123;
    console.log(&#39;error &#39;, error)

&#125;
</code></pre>
<h3 id="建立点对点的信道"><a href="#建立点对点的信道" class="headerlink" title="建立点对点的信道"></a>建立点对点的信道</h3><p>WebRTC使用RTCPeerConnection建立连接传送流数据，在建立RTCPeerConnection实例之后，想要建立点对点的信道，需要做两件事：</p>
<pre>
1. 确定本机上的媒体流的特性，比如分辨率、编解码能力啥的（SDP描述符）
    - 通过offer和answer交换SDP描述符：
    - 甲和乙各自建立一个RTCPeerConnection实例pc1、pc2
    - 甲通过PC所提供的pc1.createOffer()方法建立一个包含甲的SDP描述符的offer信令
    - 甲通过PC所提供的pc1.setLocalDescription()方法，将甲的SDP描述符交给甲的PC实例
    - 甲将offer信令通过服务器发送给乙
    - 乙将甲的offer信令中所包含的的SDP描述符提取出来，通过PC所提供的pc2.setRemoteDescription()方法交给乙的PC实例
    - 乙通过PC所提供的pc2.createAnswer()方法建立一个包含乙的SDP描述符answer信令
    - 乙通过PC所提供的pc2.setLocalDescription()方法，将乙的SDP描述符交给乙的PC实例
    - 乙将answer信令通过服务器发送给甲
    - 甲接收到乙的answer信令后，将其中乙的SDP描述符提取出来，调用pc1.setRemoteDescripttion()方法交给甲自己的PC实例
    
2. 连接两端的主机的网络地址（ICE Candidate）
    ICE (交互式连接建立) 是一个被WebRTC使用的框架（跟其他技术在一起使用），它被用在两端之间的连接，不管是何种网络类型 (通常用在视频或语音聊天)。这个协议让两端能够互相找到对方并建立一个连接，即便它们都使用了网络地址转译 (NAT) 去跟内网的其他设备共享了一个公网 IP 地址。
    - 通过ICE框架建立NAT/防火墙穿越的连接来获得这个外界可以直接访问的地址，RTCPeerConnection在创立的时候可以将ICE服务器的地址传递进去，如：
</pre>
<pre><code class="js">const iceServer = &#123;
    &quot;iceServers&quot;: [&#123;
        &quot;url&quot;: &quot;stun:stun.l.google.com:19302&quot;
    &#125;]
&#125;;
</code></pre>
<pre><code class="js">const pc = new RTCPeerConnection(iceServer);
</code></pre>
<ul>
<li>甲、乙各创建配置了ICE服务器的PC实例，并为其添加onicecandidate事件回调</li>
<li>当网络候选可用时，将会调用onicecandidate函数</li>
<li>在回调函数内部，甲或乙将网络候选的消息封装在ICE Candidate信令中，通过服务器中转，传递给对方</li>
<li>甲或乙接收到对方通过服务器中转所发送过来ICE Candidate信令时，将其解析并获得网络候选，将其通过PC实例的addIceCandidate()方法加入到PC实例中</li>
<li>连接创立完成，可以向RTCPeerConnection中通过addStream()加入流来传输媒体流数据</li>
</ul>
<h4 id="提议-x2F-应答协商"><a href="#提议-x2F-应答协商" class="headerlink" title="提议&#x2F;应答协商"></a>提议&#x2F;应答协商</h4><p>要在二者之间建立连接，必须在二者之间建立会话。offer&#x2F;answer是一种“一次性通过”型协商机制。实际中该过程可能会反复多次。<br>WebRTC使用RTCSessionDescription对象表示提议和应答。每个浏览器都将生成一个该对象。<br>本地浏览器只关注两个特定的调用：</p>
<pre><code class="js">// 将我的会话描述告知我的浏览器
pc.setLocalDescription(mySessionDescription)
...
// 将对等端的会话描述告知我的浏览器
pc.setRemoteDescription(yourSessionDescription)
</code></pre>
<p><strong>生成提议、应答：</strong></p>
<pre><code class="js">// 生成提议
pc.createOffer(gotOffer, didntGetOffer)
 
function gotOffer(aSessionDescription) &#123;
    setLocalDescription(aSessionDescription)
    ...
    // 现在可以将会话描述（提议offer）发送给对等端，以便对等端
    // a)、将提议传递给setRemoteDescription
    // b)、调用createAnswer
&#125;
 
// 生成应答
pc.createAnswer(gotAnswer, didntGetAnswer)
 
function gotAnswer(aSessionDescription) &#123;
    setLocalDescription(aSessionDescription)
    ...
    // 现在将会话描述（应答answer）发送给对等端，以便对等端
    // a)、将应答传递给setRemoteDescription
&#125;
</code></pre>
<h4 id="数据通道"><a href="#数据通道" class="headerlink" title="数据通道"></a>数据通道</h4><p>RTCDataChannel，数据通道是浏览器之间建立的非媒体的交互连接。即不传递媒体消息，绕过服务器直接传递数据。相比WebSocket、http消息，数据通道支持流量大、延迟低。<br>注意： 单个对等连接中的多个数据通道底层共享一个流，所以只需一次offer、answer即可建立首个数据通道。之后再建立数据通道无需再次进行offer、answer交换。 典型应用：游戏实时状态更新。</p>
<pre><code class="js">pc = new RTCPeerConnection()
dc = pc.createDataChannel(‘&#39;)
// 一端创建完数据通道后，另一端只需要监听ondatachannel事件即可：
pc.ondatachannel = function(e) &#123;
    dc = e.channel
    // 此时，两个对等端已经彼此建立数据通道，可以直接相互发送消息：
    dc.send(&#39;i am a text string for sending’)
    dc.onmessage = function(e) &#123;
        console.log(&#39;收到消息：&#39;, e.data)
    &#125;
&#125;
</code></pre>

	</div>
	<div class="meta split">
		<time class="post-date" datetime="2023-07-17T06:30:59.000Z" itemprop="datePublished">2023-07-17</time>
	</div>
</article>

<!--评论-->

	
<div class="ds-thread" data-thread-key="js/webRTC/01" data-title="webRTC开发" data-url="http://yoursite.com/2023/07/17/js/webRTC/01/"></div>
<script type="text/javascript">

var duoshuoQuery = {short_name:"yumemor"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>


  
</div>


  <svg id="bigTriangleColor" width="100%" height="40" viewBox="0 0 100 102" preserveAspectRatio="none">
    <path d="M0 0 L50 100 L100 0 Z"></path>
  </svg>

  


  <div class="wrapper"></div>





<div class="fat-footer">
	<div class="wrapper">
		<div class="layout layout--center">
			<div class="layout__item palm-mb">
				<div class="media">
					<img class="headimg" src='/avator.jpg' alt='Gator Law'>
					<div class="media__body">
						<h4>夏木なつき青あお</h4>
						<p class='site-description'>生命不息，折腾不止。</p>
					</div>
				</div>
				<div class="author-contact">
					<ul>
						
							
							<li>
				        		<a href="https://github.com/xiamuqing" target="_blank">
				        			
				        				<i class="iconfont icon-github"></i>
				        			
				        		</a>
				        	</li>
						
							
							<li>
				        		<a href="https://mp.weixin.qq.com/s/aeEKARwDs-a0W9xHz_4ljw" target="_blank">
				        			
				        				<i class="iconfont icon-douban"></i>
				        			
				        		</a>
				        	</li>
						
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>

<footer class="footer" role="contentinfo">
	<div class="wrapper wrapper--wide split split--responsive">
		<span>Theme by <a target="_blank" rel="noopener" href="http://github.com/yumemor">Yumemor</a>. Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></span>
	</div>
</footer>

	<!-－这里导入了 lib.js 里面涵盖了 jQuery 等框架 所以注释掉-->
	<!--
<script src="http://lib.sinaapp.com/js/jquery/2.0/jquery.min.js"></script>
-->
	
<script src="/js/lib.js"></script>

	
<script src="/js/google-code-prettify/prettify.js"></script>

	
<script src="/js/module.js"></script>

	
<script src="/js/script.js"></script>

	<script type='text/javascript'>
		//代码高亮
		$(document).ready(function(){
	 		$('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
   			prettyPrint();
		});
	</script>
	</body>
</html>